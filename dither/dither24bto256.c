/* 
dither algorithmic for bitmap 24bit to 8bit palette.
bitmap fomat with none RLE, BGR

function dither(BYTE *image, int width, int height, int bytesperline, BYTE *outimage)
function : 
	dither 24bit to 8bit palette
parameters:
	image: pixels of lines
	width*height: image size
	bytesperline: bytes of one line's pixels
	outimage: 8bit palette pixels value output

   --pclion
*/

#define COLORS 216
#define MAXWIDTH 2048

typedef unsigned char BYTE;

static unsigned char ytable[256] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	// 26 dup(0)
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 51 dup(1)
	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
	5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5		// 26 dup(5)
	};

unsigned char colormap[216][3] = {
	  0,   0,   0,
	  0,   0,  51,
	  0,   0, 102,
	  0,   0, 153,
	  0,   0, 204,
	  0,   0, 255,
	  0,  51,   0,
	  0,  51,  51,
	  0,  51, 102,
	  0,  51, 153,
	  0,  51, 204,
	  0,  51, 255,
	  0, 102,   0,
	  0, 102,  51,
	  0, 102, 102,
	  0, 102, 153,
	  0, 102, 204,
	  0, 102, 255,
	  0, 153,   0,
	  0, 153,  51,
	  0, 153, 102,
	  0, 153, 153,
	  0, 153, 204,
	  0, 153, 255,
	  0, 204,   0,
	  0, 204,  51,
	  0, 204, 102,
	  0, 204, 153,
	  0, 204, 204,
	  0, 204, 255,
	  0, 255,   0,
	  0, 255,  51,
	  0, 255, 102,
	  0, 255, 153,
	  0, 255, 204,
	  0, 255, 255,
	 51,   0,   0,
	 51,   0,  51,
	 51,   0, 102,
	 51,   0, 153,
	 51,   0, 204,
	 51,   0, 255,
	 51,  51,   0,
	 51,  51,  51,
	 51,  51, 102,
	 51,  51, 153,
	 51,  51, 204,
	 51,  51, 255,
	 51, 102,   0,
	 51, 102,  51,
	 51, 102, 102,
	 51, 102, 153,
	 51, 102, 204,
	 51, 102, 255,
	 51, 153,   0,
	 51, 153,  51,
	 51, 153, 102,
	 51, 153, 153,
	 51, 153, 204,
	 51, 153, 255,
	 51, 204,   0,
	 51, 204,  51,
	 51, 204, 102,
	 51, 204, 153,
	 51, 204, 204,
	 51, 204, 255,
	 51, 255,   0,
	 51, 255,  51,
	 51, 255, 102,
	 51, 255, 153,
	 51, 255, 204,
	 51, 255, 255,
	102,   0,   0,
	102,   0,  51,
	102,   0, 102,
	102,   0, 153,
	102,   0, 204,
	102,   0, 255,
	102,  51,   0,
	102,  51,  51,
	102,  51, 102,
	102,  51, 153,
	102,  51, 204,
	102,  51, 255,
	102, 102,   0,
	102, 102,  51,
	102, 102, 102,
	102, 102, 153,
	102, 102, 204,
	102, 102, 255,
	102, 153,   0,
	102, 153,  51,
	102, 153, 102,
	102, 153, 153,
	102, 153, 204,
	102, 153, 255,
	102, 204,   0,
	102, 204,  51,
	102, 204, 102,
	102, 204, 153,
	102, 204, 204,
	102, 204, 255,
	102, 255,   0,
	102, 255,  51,
	102, 255, 102,
	102, 255, 153,
	102, 255, 204,
	102, 255, 255,
	153,   0,   0,
	153,   0,  51,
	153,   0, 102,
	153,   0, 153,
	153,   0, 204,
	153,   0, 255,
	153,  51,   0,
	153,  51,  51,
	153,  51, 102,
	153,  51, 153,
	153,  51, 204,
	153,  51, 255,
	153, 102,   0,
	153, 102,  51,
	153, 102, 102,
	153, 102, 153,
	153, 102, 204,
	153, 102, 255,
	153, 153,   0,
	153, 153,  51,
	153, 153, 102,
	153, 153, 153,
	153, 153, 204,
	153, 153, 255,
	153, 204,   0,
	153, 204,  51,
	153, 204, 102,
	153, 204, 153,
	153, 204, 204,
	153, 204, 255,
	153, 255,   0,
	153, 255,  51,
	153, 255, 102,
	153, 255, 153,
	153, 255, 204,
	153, 255, 255,
	204,   0,   0,
	204,   0,  51,
	204,   0, 102,
	204,   0, 153,
	204,   0, 204,
	204,   0, 255,
	204,  51,   0,
	204,  51,  51,
	204,  51, 102,
	204,  51, 153,
	204,  51, 204,
	204,  51, 255,
	204, 102,   0,
	204, 102,  51,
	204, 102, 102,
	204, 102, 153,
	204, 102, 204,
	204, 102, 255,
	204, 153,   0,
	204, 153,  51,
	204, 153, 102,
	204, 153, 153,
	204, 153, 204,
	204, 153, 255,
	204, 204,   0,
	204, 204,  51,
	204, 204, 102,
	204, 204, 153,
	204, 204, 204,
	204, 204, 255,
	204, 255,   0,
	204, 255,  51,
	204, 255, 102,
	204, 255, 153,
	204, 255, 204,
	204, 255, 255,
	255,   0,   0,
	255,   0,  51,
	255,   0, 102,
	255,   0, 153,
	255,   0, 204,
	255,   0, 255,
	255,  51,   0,
	255,  51,  51,
	255,  51, 102,
	255,  51, 153,
	255,  51, 204,
	255,  51, 255,
	255, 102,   0,
	255, 102,  51,
	255, 102, 102,
	255, 102, 153,
	255, 102, 204,
	255, 102, 255,
	255, 153,   0,
	255, 153,  51,
	255, 153, 102,
	255, 153, 153,
	255, 153, 204,
	255, 153, 255,
	255, 204,   0,
	255, 204,  51,
	255, 204, 102,
	255, 204, 153,
	255, 204, 204,
	255, 204, 255,
	255, 255,   0,
	255, 255,  51,
	255, 255, 102,
	255, 255, 153,
	255, 255, 204,
	255, 255, 255 
	};

void dither(BYTE *image, int width, int height, int bytesperline, BYTE *outimage)
{
    static short int ed[MAXWIDTH][3] = {0};      /* Errors distributed down, i.e., */
                                        /* to the next line.              */
    int x, y;
	short int h, c, v[3],              /* Working variables              */
		eb[3],					// backup error part last line
		e[4],                           /* Error parts (7/8,1/8,5/8,3/8). */
        ef[3],                          /* Error distributed forward.     */
		error;
	int remainder;
	BYTE nc;
	
	remainder = bytesperline - width - width - width;

	for (x=0; x<width+2; ++x) {
        ed[x][2] = ed[x][1] = ed[x][0] = 0;
    }

	for (y=0; y<height; ++y) {
        ef[0] = ef[1] = ef[2] = 0;      /* No forward error for first dot */
/*
		if (y<height-1)
			nextline = image + bytesperline;
		else 
			nextline = ed;
*/
		eb[0] = ed[0][0];
		eb[1] = ed[0][1]; 
		eb[2] = ed[0][2];
		ed[0][0] = ed[0][1] = ed[0][2] = 0;
		for (x=0; x<width; ++x) {
                v[0] = *image++ + eb[0] + ef[0];  /* Add errors from    */
                if (v[0] < 0) v[0] = 0;
                else if (v[0] > 255) v[0] = 255;
                v[1] = *image++ + eb[1] + ef[1];
                if (v[1] < 0) v[1] = 0; 
                else if (v[1] > 255) v[1] = 255; 
                v[2] = *image++ + eb[2] + ef[2];
                if (v[2] < 0) v[2] = 0; 
                else if (v[2] > 255) v[2] = 255; 
				
				eb[0] = ed[x+1][0];	// backup ed[x+1]
				eb[1] = ed[x+1][1];
				eb[2] = ed[x+1][2];
				nc = (ytable[v[2]]*6+ytable[v[1]])*6+ytable[v[0]];
				*outimage++ = nc;


/*	  X 7
	3 5 1
*/

            for (c=0; c<3; ++c) {
                error = v[c] - colormap[nc][2-c];		//bmp is BGRBGR... palette is RGBRGB...
                h = error >> 1;                         // half of error
                ed[x+1][c] = h >> 3;                // 1/8 = e[1] 
                ef[c] = h - ed[x+1][c];             // 7/8 
                h = error - h;                       // Steinberg weights. 
				e[2] = (5 * h) >> 3;			// 5/8
                ed[x][c] += e[2];
				e[3] = h - e[2];				// 3/8
                if (x > 0) ed[x-1][c] += e[3];
            }

	} /* next x */
		image += remainder;
    } /* next y */
}

